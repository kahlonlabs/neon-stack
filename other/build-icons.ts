import { mkdir, readFile, writeFile } from 'node:fs/promises'
import { join, relative } from 'node:path'
import { cwd } from 'node:process'
import { $, Glob } from 'bun'

const inputDir = join(cwd(), 'other', 'svg-icons')
const inputDirRelative = relative(cwd(), inputDir)
const outputDir = join(cwd(), 'app', 'components', 'ui', 'icons')

await mkdir(outputDir, { recursive: true })

const files: string[] = []

for await (const file of new Glob('**/*.svg').scan(inputDir)) {
  files.push(file)
}

files.sort((a, b) => a.localeCompare(b))

const shouldVerboseLog = process.argv.includes('--log=verbose')
const logVerbose = shouldVerboseLog ? console.log : () => {}

if (files.length === 0) {
  console.log(`No SVG files found in ${inputDirRelative}`)
} else {
  await generateIconFiles()
}

async function generateIconFiles() {
  const spriteFilepath = join(outputDir, 'sprite.svg')
  const typeOutputFilepath = join(outputDir, 'name.d.ts')
  const currentSprite = await readFile(spriteFilepath, 'utf8').catch(() => '')
  const currentTypes = await readFile(typeOutputFilepath, 'utf8').catch(
    () => '',
  )

  const iconNames = files.map((file) => iconName(file))

  const spriteUpToDate = iconNames.every((name) =>
    currentSprite.includes(`id=${name}`),
  )
  const typesUpToDate = iconNames.every((name) =>
    currentTypes.includes(`"${name}"`),
  )

  if (spriteUpToDate && typesUpToDate) {
    logVerbose('Icons are up to date')
    return
  }

  logVerbose(`Generating sprite for ${inputDirRelative}`)

  const spriteChanged = await generateSvgSprite({
    files,
    inputDir,
    outputPath: spriteFilepath,
  })

  for (const file of files) {
    logVerbose('âœ…', file)
  }
  logVerbose(`Saved to ${relative(cwd(), spriteFilepath)}`)

  const stringifiedIconNames = iconNames.map((name) => JSON.stringify(name))

  const typeOutputContent = `// This file is generated by npm run build:icons

export type IconName =
\t| ${stringifiedIconNames.join('\n\t| ')};
`
  const typesChanged = await writeIfChanged(
    typeOutputFilepath,
    typeOutputContent,
  )

  logVerbose(`Manifest saved to ${relative(cwd(), typeOutputFilepath)}`)

  const readmeChanged = await writeIfChanged(
    join(outputDir, 'README.md'),
    `# Icons

This directory contains SVG icons that are used by the app.

Everything in this directory is generated by \`npm run build:icons\`.
`,
  )

  if (spriteChanged || typesChanged || readmeChanged) {
    console.log(`Generated ${files.length} icons`)
  }
}

function iconName(file: string) {
  return file.replace(/\.svg$/, '')
}

/**
 * Creates a single SVG file that contains all the icons
 */
async function generateSvgSprite({
  files,
  inputDir,
  outputPath,
}: {
  files: string[]
  inputDir: string
  outputPath: string
}) {
  const rewriter = new HTMLRewriter()
    .onDocument({
      comments(comment) {
        comment.remove()
      },
      text(text) {
        text.remove()
      },
    })
    .on('svg', {
      element(element) {
        element.tagName = 'symbol'

        element.removeAttribute('height')
        element.removeAttribute('version')
        element.removeAttribute('width')
        element.removeAttribute('xmlns')
        element.removeAttribute('xmlns:xlink')
      },
    })

  // Each SVG becomes a symbol and we wrap them all in a single SVG
  const symbols = await Promise.all(
    files.map(async (file) => {
      const input = await readFile(join(inputDir, file), 'utf8')
      const transformed = rewriter.transform(new Response(input))
      return transformed.text()
    }),
  )

  const output = [
    '<?xml version="1.0" encoding="UTF-8"?>',
    '<!-- This file is generated by npm run build:icons -->',
    '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">',
    '<defs>',
    ...symbols,
    '</defs>',
    '</svg>',
    '',
  ].join('\n')

  return writeIfChanged(outputPath, output)
}

async function writeIfChanged(filepath: string, newContent: string) {
  const currentContent = await readFile(filepath, 'utf8').catch(() => '')
  if (currentContent === newContent) return false
  await writeFile(filepath, newContent, 'utf8')
  return true
}
